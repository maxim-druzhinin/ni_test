
Реализуем `pid namespace`

Общие моменты:

* Все задание в целом построено вокруг `fork`/`clone`/`wait`/`exit`/`ps_list`

* Гарантируется, что за проблемы с другими вызовами балл снижаться не будет

* Если вы придумаете механизм, в котором часть заданий будет корректно реализована, а часть
будет невозможна в принципе, это ok в том плане, что не помешает получить частичный балл
за сделанное (например, можно сделать первые 6 заданий, полагая, что могут быть только
2 пространства и в принципе не рассчитывая на древовидность)

* Описанные сценарии подробны, но все описать сложно. Для полного балла ожидается корректная
работа любых разумных и близких по смыслу сценариев.

Например, есть конкретный сценарий в задании 4. Он подразумевает, что при последующем усложнении
порожденного пространства, по мере завершения всех его процессов, структуры, отвечающие за это
пространство, освободятся.

Освобождение ресурсов может быть отложено до какого-то понятного и разумного момента.
Например, если реализуется вложенность `namespace`-ов, то может возникнуть следующий сценарий.

Сначала создается новый процесс в новом `namespace`-е. Потом из него создается еще один процесс в
новом, вложенном `namespace`-е. После чего процесс-создатель объемлющего namespace-а завершается.
И он является последним процессом в своем `namespace`-е. 

Вы можете сделать так, чтобы этот опустевший
`namespace` сразу удалялся и его управляющая структура помечалась как свободная - и это будет нормально.

Вы можете решить, что хотя `namespace` опустел, но у него остались непустые подпространства. И вам можем
может быть удобно его управляющую структуру сохранять - пока подпространства существуют. И это тоже
нормально.

Ненормальным будет просто никогда не освобождать такую структуру.


С каждым заданием модель усложняется и все достигнутое ранее должно не только сохраняться,
но и масштабироваться на новую модель. Если не сохраняется, то это не повлияет на балл за более ранние задания.

Схема работы не должна закладываться на текущие настройки: максимальное количество одновременно работающих процессов
и т.п.





## Задание 1. Реализуем системный вызов для создания pid namespace

Стоимость: 1 балл

Чтобы не умножать новые имена, назовем его `clone`. Но, в отличие от `clone` в `Linux`,
у нашего не будет зоопарка опций.

Поэтому любой вызов `clone()` будет пониматься как `fork()` с созданием нового namespace.

После успешного завершения:

* в родителя возвращается уникальный `pid`

* в ребенка возвращается 0, `getpid` в ребенке возвращает 1

* `getppid` в ребенке возвращает 0 (родитель есть, но его `pid` мы не знаем)

* Вызов `ps_list` в родительском `namespace` показывает наличие созданного процесса (который надо
как-то притормозить, чтобы проверить этот факт)





## Задание 2. Реализуем exit из единственного процесса в namespace

Стоимость: 1 балл

После успешного вызова `clone` вызов в ребенке `exit` должен аккуратно закрыть `namespace`.
В том смысле, что структуры, созданные ради представления нового `namespace`, должны быть освобождены.

После вызова `exit` заснувший `wait` в родителе должен проснуться.

Вызов `ps_list` в родительском `namespace` после завершения `wait` должен показать отсутствие
процесса.





## Задание 3. Реализуем fork внутри нового namespace

Стоимость: 1 балл

Если после успешного вызова `clone` в ребенке успешно вызывается `fork`, то

* в ребенке возращается 0, `getpid` возврашает уникальный в новом пространстве pid

* в родителе возвращается тот же `pid`, что возвращает `getpid` в ребенке

* вызов `ps_list` из родительского `namespace` должен показать оба эти
процесса с `pid` родительского `namespace` - если они еще не завершились





## Задание 4. Реализуем exit из ребенка в новом namespace

Стоимость: 1 балл

Если после успешного вызова `clone` в ребенке вызывается `fork`, а в его
ребенке успешно вызывается `exit`, то

* После вызова `exit` вызов `wait` в родителе должен проснуться

* вызов `ps_list` из родительского `namespace` должен показать только один процесс из порожденного
`namespace` и с правильным `pid` (тем же, что вернул `fork`)



## Задание 5. Реализуем exit из ребенка в новом namespace, у которого уже есть свой ребенок

Стоимость: 1 балл

Если после успешного вызова `clone` в ребенке вызывается `fork`, в его
ребенке (назовем его вторым процессом) снова успешно вызывается `fork` (порожденный им процесс
назовем третьим), третий что-то делает, а во втором вызывается `exit`, то

* третий процесс должен быть усыновлен `init`-процессу своего пространства

* его `getppid` должен быть возврашать 1

* его `exit` должен ловить `wait` `init`-процесса своего пространства



## Задание 6. Реализуем exit из корневого процесса нового `namespace`, когда там еще есть процессы

Стоимость: 2 балла

Вызовом `clone` создаем новый `namespace`. Там вызываем `fork`, а потом выходим.

То есть, у нас ушел `init`-процесс текущего пространства, но в пространстве остались другие процессы.

Те другие процессы, которые были непосредственно его детьми, должны усыновиться `init`-процессу родительского
пространства.

Их `getppid` должен теперь возвращать 0.

А их `exit` должен ловить `wait` того процесса, которому они усыновились.

Но эти процессы не должны сами переехать в родительское пространство. Как и то, что они дальше породят.




## Задание 7. Позаботимся о том, чтобы можно было создавать дерево `namespace`-ов

Стоимость: 2 балла

Будем считать, что глубина должна быть не больше, чем 8. При попытке ее превысить clone должен возвращать
ошибку.

Ширина - не ограничена сама по себе. (Но косвенно ограничена, например, максимальным количеством работающих процессов).

Все разумные сценарии должны переноситься на этот случай.

Например, если вышел `init`-процесс текущего пространства, а у родительского его тоже нет, должны пойти еще выше
в поисках родителя.




## Задание 8. Убедимся, что `ps_list` корректно работает во всех `namespace`-ах любого уровня вложенности

Стоимость: 1 балл

Во всех разумных сценариях из предыдущих заданий `ps_list`, вызванный из порожденных пространств, должен
возвращать данные, соответственно текущему пространству.

Он должен видеть процессы непосредственно своего `namespace`-а и процессы всех производных `namespace`-ов. И никаких
других - не видеть.
